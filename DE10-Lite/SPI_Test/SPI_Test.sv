
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module SPI_Test(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,

	//////////// Arduino //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

//frequency the SPI operates on
localparam desiredFrequency = 100.0 / 2.0, divisor = 50_000_000 / desiredFrequency;

//clock signals
logic [31:0] clkCounter;
logic clk;

//SRAM SPI communication signals
logic [7:0] out_reg;
logic output_valid;
logic MISO;
logic [7:0] inst;
logic [23:0] address;
logic [7:0] in_reg;

//signal for the test states
logic [12:0] state_counter;

//signal for display
logic display_valid;
logic [7:0] display_bits;



//test signal
logic[16:0] address_counter;

//=======================================================
//  Structural coding
//=======================================================

bcd_to_segment B0(HEX5, GPIO[33]&{4'b0001});

//constructing slower clk for SPI protocol
always_ff @(posedge MAX10_CLK1_50)
begin
	if (clkCounter == 0)
	begin
		clkCounter <= divisor;
		clk <= ~clk;
	end
	else
	begin
		clkCounter <= clkCounter - 1;
	end
end

assign GPIO[35] = clk;
SRAM_SPI_RW S0(GPIO[31], GPIO[32], out_reg, output_valid, GPIO[33], clk, inst, address, in_reg);
n_bit_register #8 R0(display_bits, out_reg, clk, display_valid, 0);

logic [7:0]tempSeg;
display D0(HEX0, HEX1, HEX2, HEX3, HEX4, tempSeg, display_bits);

enum {WAIT, WRITE, HOLD1, READ, HOLD2} states = WAIT;

always_ff @(posedge clk)
begin
	case (states)
		WAIT:
		begin
			if(SW[0])
				begin
				if (state_counter == 0)
				begin
					states <= WRITE;
					inst <= 2;
					address <= address_counter;
					in_reg <= address_counter + 150;
				end
				else
				begin
					state_counter <= state_counter + 1;
				end
			end
			else
			begin
				inst <= 0;
			end
		end
		WRITE:
		begin
			if (output_valid)
			begin
				states <= HOLD1;
				address_counter <= address_counter + 1;
			end
			else
			begin
				inst <= 0;
			end
		end
		HOLD1:
		begin
			states <= READ;
			inst <= 3;
		end
		READ:
		begin
			if (output_valid) 
			begin
				states <= HOLD2;
				display_valid <= 1;
			end
			else
			begin
				inst <= 0;
			end
		end
		HOLD2:
		begin
			states <= WAIT;
			inst <= 0;
			address <= 0;
			display_valid <= 0;
		end
	endcase
end


endmodule
