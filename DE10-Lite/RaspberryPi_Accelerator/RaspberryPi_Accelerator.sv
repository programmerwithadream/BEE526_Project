
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module RaspberryPi_Accelerator(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,

	//////////// Arduino //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  parameter declarations
//=======================================================

//frequency the SPI operates on
localparam desiredFrequency = 10000.0 / 2.0, divisor = 50_000_000 / desiredFrequency;

//pin numbers for raspberry pi, sram0,1,2,3 signals
localparam int MOSI_PIN = 1;
localparam int MISO_PIN = 3;
localparam int RPICLK_PIN = 5;
localparam int CS0_PIN = 0;
localparam int CS1_PIN = 2;

localparam int CE0_PIN = 22;
localparam int SO0_PIN = 24;
localparam int SCLK0_PIN = 23;
localparam int SI0_PIN = 25;

localparam int CE1_PIN = 18;
localparam int SO1_PIN = 20;
localparam int SCLK1_PIN = 19;
localparam int SI1_PIN = 21;

localparam int CE2_PIN = 26;
localparam int SO2_PIN = 28;
localparam int SCLK2_PIN = 27;
localparam int SI2_PIN = 29;

localparam int CE3_PIN = 32;
localparam int SO3_PIN = 34;
localparam int SCLK3_PIN = 33;
localparam int SI3_PIN = 35;

//pins for RPi signals to instruction handler
localparam int SRAM_SELECT0_PIN = 10; //connect to RPI GPIO 24
localparam int SRAM_SELECT1_PIN = 12; //connect to RPI GPIO 23
localparam int INST_VALID_PIN = 14; //connect to RPI GPIO pin 17
localparam int JOB_DONE_PIN = 13; //connect to RPI GPIO pin  27
localparam int EXECUTE_TASK_PIN = 11; //connect to RPI GPIO pin 22

//=======================================================
//  REG/WIRE declarations
//=======================================================

//clock signals
logic [31:0] clkCounter;
logic clk;

//signals for raspberry pi
logic MOSI, MISO, RPiclk;
logic cs[1:0];

//signals for two-to-four decoder
logic [3:0] d;
logic [1:0] sram_select;

//signals going into srams
//signals from device into sram
logic [3:0] si;
//signals from sram to device
logic [3:0] so;
//sram system clocks
logic [3:0] sclk;
//sram chip enables
logic [3:0] ce;

//signals from fpga
logic [3:0] fi;
logic [3:0] fs;

//signals for spi read/write modules
logic [3:0] output_valid;
logic [7:0] inst [3:0];
logic [23:0] address [3:0];
logic [7:0] in_reg [3:0];
logic [23:0] length [3:0];

//handshake signals between raspberry pi  and fpga
logic inst_valid, job_done, execute_task;

//=======================================================
//  Structural coding
//=======================================================

//constructing slower clk for SPI protocol
always_ff @(posedge MAX10_CLK1_50)
begin
	if (clkCounter == 0)
	begin
		clkCounter <= divisor;
		clk <= ~clk;
	end
	else
	begin
		clkCounter <= clkCounter - 1;
	end
end

//assigning raspberry pi signals to their corresponding GPIO pins
assign MOSI = GPIO[MOSI_PIN];
assign GPIO[MISO_PIN] = MISO;
assign RPiclk = GPIO[RPICLK_PIN];
assign cs[0] = GPIO[CS0_PIN];
assign cs[1] = GPIO[CS1_PIN];

//assigning so signals to their corresponding SRAMs
assign so[0] = GPIO[SO0_PIN];
assign so[1] = GPIO[SO1_PIN];
assign so[2] = GPIO[SO2_PIN];
assign so[3] = GPIO[SO3_PIN];

//signals between RPi and FPGA task_manager
assign sram_select[0] = GPIO[SRAM_SELECT0_PIN];
assign sram_select[1] = GPIO[SRAM_SELECT1_PIN];
assign execute_task = GPIO[EXECUTE_TASK_PIN];


//FPGA read/write modules
SRAM_SPI_RW S0(fs[0], fi[0], clk, inst[0], address[0], in_reg[0], length[0], output_valid[0]);
SRAM_SPI_RW S1(fs[1], fi[1], clk, inst[1], address[1], in_reg[1], length[1], output_valid[1]);
SRAM_SPI_RW S2(fs[2], fi[2], clk, inst[2], address[2], in_reg[2], length[2], output_valid[2]);
SRAM_SPI_RW S3(fs[3], fi[3], clk, inst[3], address[3], in_reg[3], length[3], output_valid[3]);

//two-to-four decoder used for select signals for muxes
two_to_four_decoder D0(d[0], d[1], d[2], d[3], sram_select[0], sram_select[1]);

//muxes for sram0
two_to_one_mux MI0(si[0], fi[0], MOSI, d[0]);
two_to_one_mux MSCLK0(sclk[0], clk, RPiclk, d[0]);
two_to_one_mux MCE0(ce[0], fs[0], cs[0], d[0]);

//assign signals for sram0
assign GPIO[CE0_PIN] = ce[0];
assign SO0 = GPIO[SO0_PIN];
assign GPIO[SCLK0_PIN] = sclk[0];
assign GPIO[SI0_PIN] = si[0];

//muxes for sram1
two_to_one_mux MI1(si[1], fi[1], MOSI, d[1]);
two_to_one_mux MSCLK1(sclk[1], clk, RPiclk, d[1]);
two_to_one_mux MCE1(ce[1], fs[1], cs[0], d[1]);

//assign signals for sram1
assign GPIO[CE1_PIN] = ce[1];
assign SO1 = GPIO[SO1_PIN];
assign GPIO[SCLK1_PIN] = sclk[1];
assign GPIO[SI1_PIN] = si[1];

//muxes for sram2
two_to_one_mux MI2(si[2], fi[2], MOSI, d[2]);
two_to_one_mux MSCLK2(sclk[2], clk, RPiclk, d[2]);
two_to_one_mux MCE2(ce[2], fs[2], cs[0], d[2]);

//assign signals for sram2
assign GPIO[CE2_PIN] = ce[2];
assign SO2 = GPIO[SO2_PIN];
assign GPIO[SCLK2_PIN] = sclk[2];
assign GPIO[SI2_PIN] = si[2];

//muxes for sram3
two_to_one_mux MI3(si[3], fi[3], MOSI, d[3]);
two_to_one_mux MSCLK3(sclk[3], clk, RPiclk, d[3]);
two_to_one_mux MCE3(ce[3], fs[3], cs[0], d[3]);

//assign signals for sram3
assign GPIO[CE3_PIN] = ce[3];
assign SO3 = GPIO[SO3_PIN];
assign GPIO[SCLK3_PIN] = sclk[3];
assign GPIO[SI3_PIN] = si[3];

//mux for MISO signal back to raspberry pi
four_to_one_mux MMISO(MISO, SO0, SO1, SO2, SO3, sram_select[0], sram_select[1]);




//***************
//temporary test
//***************
logic [31:0] temp_inst;
logic [2:0] temp_pins;
assign temp_pins[0] = execute_task;
assign temp_pins[1] = sram_select[0];
assign temp_pins[2] = sram_select[1];
instruction_handler #32 I0(temp_inst, MOSI, RPiclk, cs[1]);
task_manager T0(inst_valid, job_done, temp_inst, execute_task, clk, sram_select, inst, address, in_reg, length, so, output_valid);
display DI0(HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, temp_pins);

endmodule
